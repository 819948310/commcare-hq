--- 
+++ 
@@ -1,11 +1,8 @@
-
 from collections import namedtuple, OrderedDict
 from itertools import chain
 import json
-from urllib import urlencode
 import uuid
 from django import forms
-from django.urls import reverse
 from django.forms import Widget
 from django.forms.utils import flatatt
 from django.template.loader import render_to_string
@@ -14,8 +11,15 @@
 from django.utils.translation import ugettext as _, ugettext_noop, ugettext_lazy
 from corehq.apps.app_manager.app_schemas.case_properties import get_case_properties
 
-from corehq.apps.userreports.reports.builder.v1.columns import \
-    QuestionColumnOption, ColumnOption, CountColumn, MultiselectQuestionColumnOption
+from corehq.apps.userreports.reports.builder.columns import (
+    QuestionColumnOption,
+    CountColumn,
+    MultiselectQuestionColumnOption,
+    FormMetaColumnOption,
+    OwnernameComputedCasePropertyOption,
+    UsernameComputedCasePropertyOption,
+    CasePropertyColumnOption,
+)
 from crispy_forms import layout as crispy
 from crispy_forms.bootstrap import StrictButton
 from crispy_forms.helper import FormHelper
@@ -40,16 +44,16 @@
     DEFAULT_CASE_PROPERTY_DATATYPES,
     FORM_METADATA_PROPERTIES,
     make_case_data_source_filter,
-    make_case_property_indicator,
     make_form_data_source_filter,
-    make_form_meta_block_indicator,
-    make_form_question_indicator,
-    make_owner_name_indicator,
     get_filter_format_from_question_type,
-    make_user_name_indicator, make_multiselect_question_indicator)
+)
 from corehq.apps.userreports.exceptions import BadBuilderConfigError
+from corehq.apps.userreports.reports.builder.const import COMPUTED_USER_NAME_PROPERTY_ID, \
+    COMPUTED_OWNER_NAME_PROPERTY_ID, PROPERTY_TYPE_QUESTION, PROPERTY_TYPE_CASE_PROP, PROPERTY_TYPE_META, \
+    COUNT_PER_CHOICE
 from corehq.apps.userreports.sql import get_column_name
 from corehq.apps.userreports.ui.fields import JsonField
+from corehq.apps.userreports.util import has_report_builder_access
 from dimagi.utils.decorators.memoized import memoized
 
 # This dict maps filter types from the report builder frontend to UCR filter types
@@ -59,6 +63,15 @@
     'Numeric': 'numeric',
     'Value': 'pre',
 }
+
+STATIC_CASE_PROPS = [
+    "closed",
+    "modified_on",
+    "name",
+    "opened_on",
+    "owner_id",
+    "user_id",
+]
 
 
 class FilterField(JsonField):
@@ -140,9 +153,7 @@
         )
 
 
-class DataSourceProperty(namedtuple(
-    "DataSourceProperty", ["type", "id", "text", "column_id", "source", "is_non_numeric"]
-)):
+class DataSourceProperty(object):
     """
     A container class for information about data source properties
 
@@ -157,15 +168,115 @@
     source -- For questions, this is a dict representing the question as returned
         by Xform.get_questions(), for case properties and form metadata it is just
         the name of the property.
-    column_id -- A string to be used as the column_id for data source indicators
-        based on this property.
-    is_non_numeric -- True if we know that the property associated with this property
-        is never numeric. This would be True for form meta properties, static case
-        properties like closed and owner, and non-numeric form questions.
-        Note that a value of False does not imply that the property contains
-        numeric data, just that we don't know for sure that it doesn't (e.g.
-        case properties).
+    data_types
     """
+
+    def __init__(self, type, id, text, source, data_types):
+        self._type = type
+        self._id = id
+        self._text = text
+        self._source = source
+        self._data_types = data_types
+
+    def to_view_model(self):
+        """
+        Return a dictionary representation to be used by the js
+        """
+        return {
+            "type": self._type,
+            "id": self._id,
+            "text": self._text,
+            "source": self._source,
+        }
+
+    def get_text(self):
+        return self._text
+
+    def get_type(self):
+        return self._type
+
+    def get_id(self):
+        return self._id
+
+    def get_source(self):
+        return self._source
+
+    def to_report_column_option(self):
+        if self._type == PROPERTY_TYPE_QUESTION:
+            if self._source['type'] == "MSelect":
+                return MultiselectQuestionColumnOption(self._id, self._text, self._source)
+            else:
+                return QuestionColumnOption(self._id, self._data_types, self._text, self._source)
+        elif self._type == PROPERTY_TYPE_META:
+            return FormMetaColumnOption(self._id, self._data_types, self._text, self._source)
+        else:  # self._type == PROPERTY_TYPE_CASE_PROP
+            if self._id == COMPUTED_OWNER_NAME_PROPERTY_ID:
+                return OwnernameComputedCasePropertyOption(self._id, self._data_types, self._text)
+            elif self._id == COMPUTED_USER_NAME_PROPERTY_ID:
+                return UsernameComputedCasePropertyOption(self._id, self._data_types, self._text)
+            else:
+                return CasePropertyColumnOption(self._id, self._data_types, self._text)
+
+    def _get_filter_format(self, filter_configuration):
+        """
+        Return the UCR filter type that should be used for the given filter configuration (passed from the UI).
+        """
+        selected_filter_type = filter_configuration['format']
+        if not selected_filter_type or self._type in ('question', 'meta'):
+            if self._type == 'question':
+                filter_format = get_filter_format_from_question_type(self._source['type'])
+            else:
+                assert self._type == 'meta'
+                filter_format = get_filter_format_from_question_type(self._source[1])
+        else:
+            filter_format = REPORT_BUILDER_FILTER_TYPE_MAP[selected_filter_type]
+        return filter_format
+
+    def _get_agg_type_for_filter_format(self, filter_format):
+        """
+        ColumnOption.get_indicator(aggregation) uses the aggregation type to determine what data type the indicator
+        should be. Therefore, we need to convert filter formats to aggregation types so that we can create the
+        correct type of indicator.
+        """
+        if filter_format == "numeric":
+            return "Sum"  # This could also be "Avg", just needs to force numeric
+        else:
+            return "simple"
+
+    def to_report_filter(self, configuration, index):
+        """
+        Return a UCR report filter configuration for the given configuration.
+        :param configuration:  dictionary representing options selected in UI.
+        :param index: Index of this filter in the list of filters configured by the user.
+        :return:
+        """
+        filter_format = self._get_filter_format(configuration)
+        agg = self._get_agg_type_for_filter_format(filter_format)
+        column_id = self.to_report_column_option().get_indicator(agg)['column_id']
+
+        filter = {
+            "field": column_id,
+            "slug": "{}_{}".format(column_id, index),
+            "display": configuration["display_text"],
+            "type": filter_format
+        }
+        if configuration['format'] == 'Date':
+            filter.update({'compare_as_string': True})
+        if configuration.get('pre_value') or configuration.get('pre_operator'):
+            filter.update({
+                'type': 'pre',  # type could have been "date"
+                'pre_operator': configuration.get('pre_operator', None),
+                'pre_value': configuration.get('pre_value', []),
+            })
+        return filter
+
+    def to_report_filter_indicator(self, configuration):
+        """
+        Return the indicator that would correspond to the given filter configuration
+        """
+        filter_format = self._get_filter_format(configuration)
+        agg = self._get_agg_type_for_filter_format(filter_format)
+        return self.to_report_column_option().get_indicator(agg)
 
 
 class DataSourceBuilder(object):
@@ -230,8 +341,8 @@
             assert multiselect_field, "multiselect_field is required if is_multiselect_chart_report is True"
 
             property = self.data_source_properties[multiselect_field]
-            path = ['form'] + property.source['value'].split('/')[2:]
-            choices = [c['value'] for c in property.source['options']]
+            path = ['form'] + property.get_source()['value'].split('/')[2:]
+            choices = [c['value'] for c in property.get_source()['options']]
 
             def sub_doc(path):
                 if not path:
@@ -271,51 +382,52 @@
                 "map_expression": sub_doc(path)
             }
 
-    def indicators(self, number_columns=None, is_multiselect_chart_report=False):
-        """
-        Return all the dict data source indicator configurations that could be
-        used by a report that uses the same case type/form as this DataSourceConfiguration.
-        """
-        ret = []
-        for prop in self.data_source_properties.values():
-            if prop.type == 'meta':
-                ret.append(make_form_meta_block_indicator(
-                    prop.source, prop.column_id, root_doc=is_multiselect_chart_report
-                ))
-            elif prop.type == "question":
-                if prop.source['type'] == "MSelect":
-                    # For filters and aggregation:
-                    ret.append(make_form_question_indicator(prop.source, prop.column_id))
-                    # For column display:
-                    if prop.source['options']:
-                        # A choice list indicator with no choices will throw a BadSpecError
-                        ret.append(make_multiselect_question_indicator(prop.source, prop.column_id))
-                else:
-                    indicator = make_form_question_indicator(
-                        prop.source, prop.column_id, root_doc=is_multiselect_chart_report
-                    )
-                    if prop.source['type'] == "DataBindOnly" and number_columns:
-                        if indicator['column_id'] in number_columns:
-                            indicator['datatype'] = 'decimal'
-                    ret.append(indicator)
-            elif prop.type == 'case_property' and prop.source == 'computed/owner_name':
-                ret.append(make_owner_name_indicator(prop.column_id))
-            elif prop.type == 'case_property' and prop.source == 'computed/user_name':
-                ret.append(make_user_name_indicator(prop.column_id))
-            elif prop.type == 'case_property':
-                indicator = make_case_property_indicator(
-                    prop.source, prop.column_id
-                )
-                if number_columns:
-                    if indicator['column_id'] in number_columns:
-                        indicator['datatype'] = 'decimal'
-                ret.append(indicator)
-        ret.append({
-            "display_name": "Count",
-            "type": "count",
-            "column_id": "count"
-        })
-        return ret
+    def indicators(self, columns, filters, is_multiselect_chart_report=False):
+        """
+        Return a list of indicators to be used in a data source configuration that supports the given columns and
+        indicators.
+        :param columns: A list of objects representing columns in the report.
+            Each object has a "property" and "aggregation" key
+        :param filters: A list of filter configuration objects
+        """
+        indicators = []
+        for column in columns:
+            column_option = self.report_column_options[column['property']]
+            indicators.extend(column_option.get_indicators(column['aggregation'], is_multiselect_chart_report))
+
+        for filter in filters:
+            property = self.data_source_properties[filter['property']]
+            indicator = property.to_report_filter_indicator(filter)
+            indicators.append(indicator)
+
+        # remove duplicates
+        # There can be duplicates because filters and columns could be based on the same property
+        indicators_without_dups = []
+        seen_indicator_ids = set()
+        for i in indicators:
+            if (i['column_id'], i['type']) not in seen_indicator_ids:
+                indicators_without_dups.append(i)
+                seen_indicator_ids.add((i['column_id'], i['type']))
+        indicators = indicators_without_dups
+
+        return indicators
+
+    def all_possible_indicators(self):
+        indicators = []
+        for column_option in self.report_column_options.values():
+            for agg in column_option.aggregation_options:
+                indicators.extend(column_option.get_indicators(agg))
+
+        # Remove duplicates
+        return_list = []
+        return_list_set = set()
+        for indicator in indicators:
+            as_hashable = str(indicator)
+            if as_hashable not in return_list_set:
+                return_list.append(indicator)
+                return_list_set.add(as_hashable)
+
+        return return_list
 
     @property
     @memoized
@@ -333,7 +445,6 @@
                 type="question",
                 id="/data/question1",
                 text="Enter the child's name",
-                column_id="data--question1",
                 source={
                     'repeat': None,
                     'group': None,
@@ -342,15 +453,14 @@
                     'tag': 'input',
                     'type': 'Text'
                 },
-                is_non_numeric=True
+                data_types=["string"]
             ),
             "meta/deviceID": DataSourceProperty(
                 type="meta",
                 id="meta/deviceID",
                 text="deviceID",
-                column_id="meta--deviceID",
                 source=("deviceID", "string"),
-                is_non_numeric=True
+                data_types=["string"]
             )
         }
         """
@@ -369,27 +479,23 @@
             'owner_name': _('Case Owner'),
             'mobile worker': _('Mobile Worker Last Updating Case'),
         }
-        static_case_props = [
-            "closed",
-            "modified_on",
-            "name",
-            "opened_on",
-            "owner_id",
-            "user_id",
-        ]
 
         properties = OrderedDict()
         for property in case_properties:
+            if property in DEFAULT_CASE_PROPERTY_DATATYPES:
+                data_types = DEFAULT_CASE_PROPERTY_DATATYPES[property]
+            else:
+                data_types = ["string", "decimal", "datetime"]
+
             properties[property] = DataSourceProperty(
-                type='case_property',
+                type=PROPERTY_TYPE_CASE_PROP,
                 id=property,
-                column_id=get_column_name(property),
                 text=property_map.get(property, property.replace('_', ' ')),
                 source=property,
-                is_non_numeric=property in static_case_props,
+                data_types=data_types,
             )
-        properties['computed/owner_name'] = cls._get_owner_name_pseudo_property()
-        properties['computed/user_name'] = cls._get_user_name_pseudo_property()
+        properties[COMPUTED_OWNER_NAME_PROPERTY_ID] = cls._get_owner_name_pseudo_property()
+        properties[COMPUTED_USER_NAME_PROPERTY_ID] = cls._get_user_name_pseudo_property()
         return properties
 
     @staticmethod
@@ -398,12 +504,11 @@
         # the report builder will create a related_doc indicator based
         # on the owner_id of the case.
         return DataSourceProperty(
-            type='case_property',
-            id='computed/owner_name',
-            column_id=get_column_name('computed/owner_name'),
+            type=PROPERTY_TYPE_CASE_PROP,
+            id=COMPUTED_OWNER_NAME_PROPERTY_ID,
             text=_('Case Owner'),
-            source='computed/owner_name',
-            is_non_numeric=True,
+            source=COMPUTED_OWNER_NAME_PROPERTY_ID,
+            data_types=["string"],
         )
 
     @staticmethod
@@ -412,12 +517,11 @@
         # the report builder will create a related_doc indicator based on the
         # user_id of the case
         return DataSourceProperty(
-            type='case_property',
-            id='computed/user_name',
-            column_id=get_column_name('computed/user_name'),
+            type=PROPERTY_TYPE_CASE_PROP,
+            id=COMPUTED_USER_NAME_PROPERTY_ID,
             text=_('Mobile Worker Last Updating Case'),
-            source='computed/user_name',
-            is_non_numeric=True,
+            source=COMPUTED_USER_NAME_PROPERTY_ID,
+            data_types=["string"],
         )
 
     @staticmethod
@@ -431,33 +535,56 @@
         properties = OrderedDict()
         questions = form_xml.get_questions([])
         for prop in FORM_METADATA_PROPERTIES:
+            question_type = prop[1]
+            data_type = {
+                "DateTime": "datetime",
+                "Text": "string",
+            }[question_type]
             properties[prop[0]] = DataSourceProperty(
-                type="meta",
+                type=PROPERTY_TYPE_META,
                 id=prop[0],
-                column_id=get_column_name(prop[0].strip("/")),
                 text=property_map.get(prop[0], prop[0]),
                 source=prop,
-                is_non_numeric=True,
+                data_types=[data_type]
             )
         for question in questions:
+            if question['type'] == "DataBindOnly":
+                data_types = ["string", "decimal", "datetime"]
+            elif question['type'] in ("Int", "Double", "Long"):
+                data_types = ["decimal"]
+            else:
+                data_types = ["string"]
             properties[question['value']] = DataSourceProperty(
-                type="question",
+                type=PROPERTY_TYPE_QUESTION,
                 id=question['value'],
-                column_id=get_column_name(question['value'].strip("/")),
                 text=question['label'],
                 source=question,
-                is_non_numeric=question['type'] not in ("DataBindOnly", "Int", "Double", "Long"),
+                data_types=data_types,
             )
         if form.get_app().auto_gps_capture:
             properties['location'] = DataSourceProperty(
-                type="meta",
+                type=PROPERTY_TYPE_META,
                 id='location',
-                column_id=get_column_name('location'),
                 text='location',
                 source=(['location', '#text'], 'Text'),
-                is_non_numeric=True,
+                data_types=["string"],
             )
         return properties
+
+    @property
+    @memoized
+    def report_column_options(self):
+        options = OrderedDict()
+        for id_, prop in self.data_source_properties.iteritems():
+            options[id_] = prop.to_report_column_option()
+
+        # NOTE: Count columns aren't useful for table reports. But we need it in the column options because
+        # the options are currently static, after loading the report builder a user can switch to an aggregated
+        # report.
+        count_col = CountColumn("Number of Cases" if self.source_type == "case" else "Number of Forms")
+        options[count_col.get_property()] = count_col
+
+        return options
 
     @property
     @memoized
@@ -480,19 +607,13 @@
 
 class DataSourceForm(forms.Form):
     report_name = forms.CharField()
-    chart_type = forms.ChoiceField(
-        choices=[
-            ('bar', _('Bar')),
-            ('pie', _("Pie")),
-        ],
-    )
-
-    def __init__(self, domain, report_type, max_allowed_reports, *args, **kwargs):
+
+    def __init__(self, domain, max_allowed_reports, *args, **kwargs):
         super(DataSourceForm, self).__init__(*args, **kwargs)
         self.domain = domain
-        self.report_type = report_type
         self.max_allowed_reports = max_allowed_reports
 
+        # TODO: Map reports.
         self.app_source_helper = ApplicationDataSourceUIHelper()
         self.app_source_helper.source_type_field.label = _('Forms or Cases')
         self.app_source_helper.source_type_field.choices = [("case", _("Cases")), ("form", _("Forms"))]
@@ -501,15 +622,13 @@
         report_source_fields = self.app_source_helper.get_fields()
         report_source_help_texts = {
             "source_type": _(
-                "<strong>Form</strong>: display data from form submissions.<br/><strong>Case</strong>: display "
-                "data from your cases. You must be using case management for this option."
-            ),
+                "<strong>Form</strong>: Display data from form submissions.<br/>"
+                "<strong>Case</strong>: Display data from your cases. You must be using case management for this "
+                "option."),
             "application": _("Which application should the data come from?"),
             "source": _("Choose the case type or form from which to retrieve data for this report."),
         }
         self.fields.update(report_source_fields)
-
-        self.fields['chart_type'].required = self.report_type == "chart"
 
         self.helper = FormHelper()
         self.helper.form_class = "form form-horizontal"
@@ -517,15 +636,6 @@
         self.helper.label_class = 'col-sm-3 col-md-2 col-lg-2'
         self.helper.field_class = 'col-sm-9 col-md-8 col-lg-6'
 
-        chart_type_crispy_field = None
-        if self.report_type == 'chart':
-            chart_type_crispy_field = hqcrispy.FieldWithHelpBubble(
-                'chart_type',
-                help_bubble_text=_(
-                    "<strong>Bar</strong> shows one vertical bar for each value in your case or form. "
-                    "<strong>Pie</strong> shows what percentage of the total each value is."
-                )
-            )
         report_source_crispy_fields = []
         for k in report_source_fields.keys():
             if k in report_source_help_texts:
@@ -535,22 +645,16 @@
             else:
                 report_source_crispy_fields.append(k)
 
-        top_fields = [
-            hqcrispy.FieldWithHelpBubble(
-                'report_name',
-                help_bubble_text=_(
-                    'Web users will see this name in the "Reports" section of CommCareHQ and can click to view '
-                    'the report'
-                )
-            )
-        ]
-        if chart_type_crispy_field:
-            top_fields.append(chart_type_crispy_field)
-
         self.helper.layout = crispy.Layout(
             crispy.Fieldset(
-                _('{} Report'.format(self.report_type.capitalize())),
-                *top_fields
+                _('Report'),
+                hqcrispy.FieldWithHelpBubble(
+                    'report_name',
+                    help_bubble_text=_(
+                        'Web users will see this name in the "Reports" section of CommCareHQ and can click to '
+                        'view the report'
+                    )
+                )
             ),
             crispy.Fieldset(
                 _('Data'), *report_source_crispy_fields
@@ -580,11 +684,13 @@
 
         existing_reports = ReportConfiguration.by_domain(self.domain)
         builder_reports = filter(lambda report: report.report_meta.created_by_builder, existing_reports)
-        if len(builder_reports) >= self.max_allowed_reports:
+        if has_report_builder_access(self.domain) and len(builder_reports) >= self.max_allowed_reports:
+            # Don't show the warning when domain does not have report buidler access, because this is just a
+            # preview and the report will not be saved.
             raise forms.ValidationError(_(
                 "Too many reports!\n"
                 "Creating this report would cause you to go over the maximum "
-                "number of report builder reports allowed in this domain. Your"
+                "number of report builder reports allowed in this domain. Your "
                 "limit is {number}. "
                 "To continue, delete another report and try again. "
             ).format(number=self.max_allowed_reports))
@@ -602,6 +708,8 @@
 class ConfigureNewReportBase(forms.Form):
     user_filters = FilterField(required=False)
     default_filters = FilterField(required=False)
+    report_title = forms.CharField(widget=forms.HiddenInput, required=False)
+    report_description = forms.CharField(widget=forms.HiddenInput, required=False)
     button_text = ugettext_noop('Done')
 
     def __init__(self, report_name, app_id, source_type, report_source_id, existing_report=None, *args, **kwargs):
@@ -626,10 +734,17 @@
         self.ds_builder = DataSourceBuilder(
             self.domain, self.app, self.source_type, self.report_source_id
         )
+        self.report_column_options = self.ds_builder.report_column_options
+
         self.data_source_properties = self.ds_builder.data_source_properties
-        self._properties_by_column = {
-            p.column_id: p for p in self.data_source_properties.values()
-        }
+
+        self._report_columns_by_column_id = {}
+        for column in self.report_column_options.values():
+            for agg in column.aggregation_options:
+                indicators = column.get_indicators(agg)
+                for i in indicators:
+                    self._report_columns_by_column_id[i['column_id']] = column
+
 
         # NOTE: The corresponding knockout view model is defined in:
         #       templates/userreports/reportbuilder/configure_report.html
@@ -648,35 +763,6 @@
             )
         ]
         # Add a back button if we aren't editing an existing report
-        if not self.existing_report:
-            buttons.insert(
-                0,
-                crispy.HTML(
-                    '<a class="btn btn-default" href="{}" style="margin-right: 4px">{}</a>'.format(
-                        reverse(
-                            'report_builder_select_source',
-                            args=(self.domain, self.report_type),
-                        ),
-                        _('Back')
-                    )
-                ),
-            )
-        # Add a "delete report" button if we are editing an existing report
-        else:
-            buttons.insert(
-                0,
-                crispy.HTML(
-                    '<a id="delete-report-button" class="btn btn-danger pull-right" href="{}">{}</a>'.format(
-                        reverse(
-                            'delete_configurable_report',
-                            args=(self.domain, self.existing_report._id),
-                        ) + "?{}".format(urlencode(
-                            {'redirect': reverse('reports_home', args=[self.domain])}
-                        )),
-                        _('Delete Report')
-                    )
-                )
-            )
         self.helper.layout = crispy.Layout(
             self.container_fieldset,
             hqcrispy.FormActions(crispy.ButtonHolder(*buttons)),
@@ -703,24 +789,8 @@
             ))
 
     @property
-    @memoized
-    def report_column_options(self):
-        options = OrderedDict()
-        for id_, prop in self.data_source_properties.iteritems():
-            if prop.type == "question":
-                if prop.source['type'] == "MSelect":
-                    option = MultiselectQuestionColumnOption(id_, prop.text, prop.column_id, prop.source)
-                else:
-                    option = QuestionColumnOption(id_, prop.text, prop.column_id, prop.is_non_numeric, prop.source)
-            else:
-                # meta properties
-                option = ColumnOption(id_, prop.text, prop.column_id, prop.is_non_numeric)
-            options[id_] = option
-        return options
-
-    @property
     def column_config_template(self):
-        return render_to_string('userreports/partials/v1/property_list_configuration.html')
+        return render_to_string('userreports/partials/property_list_configuration.html')
 
     @property
     def container_fieldset(self):
@@ -779,17 +849,49 @@
             crispy.Hidden('default_filters', None, data_bind="value: defaultFiltersList.serializedProperties")
         )
 
+    @property
+    def _configured_columns(self):
+        """
+        To be used by DataSourceBuilder.indicators()
+        """
+        configured_columns = [
+            {
+                "property": c['property'],
+                "aggregation": c['calculation'],
+            }
+            for c in self.cleaned_data['columns']
+        ]
+        configured_columns += [
+            {
+                "property": c,
+                "aggregation": "Group By"
+            }
+            for c in self.cleaned_data.get('group_by', [])
+        ]
+        location = self.cleaned_data.get("location")
+        if location:
+            configured_columns += [{
+                "property": location,
+                "aggregation": "simple"  # Not aggregated
+            }]
+        return configured_columns
+
     def _get_data_source_configuration_kwargs(self):
         if self._is_multiselect_chart_report:
-            base_item_expression = self.ds_builder.base_item_expression(True, self.aggregation_field)
+            base_item_expression = self.ds_builder.base_item_expression(True, self.cleaned_data['group_by'][0])
         else:
             base_item_expression = self.ds_builder.base_item_expression(False)
+
+        # We need the the column configurations that were selected by the user to determine the data source
+        # indicators.
         return dict(
             display_name=self.ds_builder.data_source_name,
             referenced_doc_type=self.ds_builder.source_doc_type,
             configured_filter=self.ds_builder.filter,
             configured_indicators=self.ds_builder.indicators(
-                self._number_columns, self._is_multiselect_chart_report
+                self._configured_columns,
+                self.cleaned_data['user_filters'] + self.cleaned_data['default_filters'],
+                self._is_multiselect_chart_report
             ),
             base_item_expression=base_item_expression,
             meta=DataSourceMeta(build=DataSourceBuildInformation(
@@ -821,7 +923,11 @@
             data_source_config_id = self._build_data_source()
             self.existing_report.config_id = data_source_config_id
         else:
-            indicators = self.ds_builder.indicators(self._number_columns)
+            indicators = self.ds_builder.indicators(
+                self._configured_columns,
+                self.cleaned_data['user_filters'] + self.cleaned_data['default_filters'],
+                self._is_multiselect_chart_report,
+            )
             if data_source.configured_indicators != indicators:
                 for property_name, value in self._get_data_source_configuration_kwargs().iteritems():
                     setattr(data_source, property_name, value)
@@ -832,6 +938,8 @@
         self.existing_report.columns = self._report_columns
         self.existing_report.filters = self._report_filters
         self.existing_report.configured_charts = self._report_charts
+        self.existing_report.title = self.cleaned_data['report_title'] or _("Report Builder Report")
+        self.existing_report.description = self.cleaned_data['report_description']
         self.existing_report.validate()
         self.existing_report.save()
         return self.existing_report
@@ -846,6 +954,32 @@
         report = ReportConfiguration(
             domain=self.domain,
             config_id=data_source_config_id,
+            title=self.cleaned_data['report_title'] or self.report_name,
+            aggregation_columns=self._report_aggregation_cols,
+            columns=self._report_columns,
+            filters=self._report_filters,
+            configured_charts=self._report_charts,
+            description=self.cleaned_data['report_description'],
+            report_meta=ReportMeta(
+                created_by_builder=True,
+                report_builder_version="2.0",
+                builder_report_type=self.report_type
+            )
+        )
+        report.validate()
+        report.save()
+        return report
+
+    def create_temp_report(self, data_source_id):
+        """
+        Creates and saves a report config.
+
+        :raises BadSpecError if report is invalid
+        """
+
+        report = ReportConfiguration(
+            domain=self.domain,
+            config_id=data_source_id,
             title=self.report_name,
             aggregation_columns=self._report_aggregation_cols,
             columns=self._report_columns,
@@ -853,6 +987,7 @@
             configured_charts=self._report_charts,
             report_meta=ReportMeta(
                 created_by_builder=True,
+                report_builder_version="2.0",
                 builder_report_type=self.report_type
             )
         )
@@ -889,7 +1024,7 @@
             ),
             UserFilterViewModel(
                 exists_in_current_version=True,
-                property='computed/owner_name',
+                property=COMPUTED_OWNER_NAME_PROPERTY_ID,
                 data_source_field=None,
                 display_text=_('Case Owner'),
                 format='Choice',
@@ -915,7 +1050,7 @@
         the knockout view model representing this filter in the report builder.
 
         """
-        exists = self._data_source_prop_exists(filter['field'])
+        exists = self._column_exists(filter['field'])
         if filter['type'] == 'pre':
             return DefaultFilterViewModel(
                 exists_in_current_version=exists,
@@ -952,9 +1087,7 @@
             indicator configuration.
         :return: The corresponding ColumnOption
         """
-        for column_option in self.report_column_options.values():
-            if column_option.indicator_id == indicator_column_id:
-                return column_option
+        return self._report_columns_by_column_id[indicator_column_id]
 
     def _get_property_id_by_indicator_id(self, indicator_column_id):
         """
@@ -964,9 +1097,9 @@
             configuration dictionary
         :return: A DataSourceProperty property id, e.g. "/data/question1"
         """
-        data_source_property = self._properties_by_column.get(indicator_column_id)
-        if data_source_property:
-            return data_source_property.id
+        column = self._report_columns_by_column_id.get(indicator_column_id)
+        if column:
+            return column.get_property()
 
     def _column_exists(self, column_id):
         """
@@ -978,16 +1111,18 @@
 
         column_id is a string like "data_date_q_d1b3693e"
         """
-        return column_id in [c.indicator_id for c in self.report_column_options.values()]
-
-    def _data_source_prop_exists(self, indicator_id):
-        """
-        Return True if there exists a DataSourceProperty corresponding to the
-        given data source indicator id.
-        :param indicator_id:
-        :return:
-        """
-        return indicator_id in self._properties_by_column
+        return column_id in self._report_columns_by_column_id
+
+    def _convert_v1_column_id_to_current_format(self, column_id):
+        """
+        Assuming column_id does not exist, assume it's from version 1 of the report builder, and attempt to convert
+        it to the current version.
+
+        This is needed because previously hidden value questions and case property columns didn't have a datatype
+        in their ids, but the builder now expects that, so this attempts to just append a datatype.
+        """
+        return column_id + "_string"
+
 
     def _get_multiselect_indicator_id(self, column_field, indicators):
         """
@@ -1011,11 +1146,6 @@
         return []
 
     @property
-    @memoized
-    def _number_columns(self):
-        return [col["field"] for col in self._report_columns if col.get("aggregation", None) in ["avg", "sum"]]
-
-    @property
     def _is_multiselect_chart_report(self):
         return False
 
@@ -1027,37 +1157,7 @@
         """
         def _make_report_filter(conf, index):
             property = self.data_source_properties[conf["property"]]
-            col_id = property.column_id
-
-            selected_filter_type = conf['format']
-            if not selected_filter_type or self.source_type == 'form':
-                if property.type == 'question':
-                    filter_format = get_filter_format_from_question_type(
-                        property.source['type']
-                    )
-                else:
-                    assert property.type == 'meta'
-                    filter_format = get_filter_format_from_question_type(
-                        property.source[1]
-                    )
-            else:
-                filter_format = REPORT_BUILDER_FILTER_TYPE_MAP[selected_filter_type]
-
-            ret = {
-                "field": col_id,
-                "slug": "{}_{}".format(col_id, index),
-                "display": conf["display_text"],
-                "type": filter_format
-            }
-            if conf['format'] == 'Date':
-                ret.update({'compare_as_string': True})
-            if conf.get('pre_value') or conf.get('pre_operator'):
-                ret.update({
-                    'type': 'pre',  # type could have been "date"
-                    'pre_operator': conf.get('pre_operator', None),
-                    'pre_value': conf.get('pre_value', []),
-                })
-            return ret
+            return property.to_report_filter(conf, index)
 
         user_filter_configs = self.cleaned_data['user_filters']
         default_filter_configs = self.cleaned_data['default_filters']
@@ -1083,170 +1183,17 @@
         return []
 
 
-class ConfigureBarChartReportForm(ConfigureNewReportBase):
-    group_by = forms.ChoiceField(label=_("Bar Chart Categories"), required=False)
-    report_type = 'chart'
-
-    def __init__(self, report_name, app_id, source_type, report_source_id, existing_report=None, *args, **kwargs):
-        super(ConfigureBarChartReportForm, self).__init__(
-            report_name, app_id, source_type, report_source_id, existing_report, *args, **kwargs
-        )
-        if self.source_type == "form":
-            self.fields['group_by'].widget = QuestionSelect(
-                attrs={'class': 'input-large'},
-                ko_value='groupBy'
-            )
-        else:
-            self.fields['group_by'].widget = Select2(
-                attrs={'class': 'input-large'},
-                ko_value='groupBy'
-            )
-        self.fields['group_by'].choices = self._group_by_choices
-
-        # Set initial value of group_by
-        if self.existing_report:
-            existing_agg_cols = existing_report.aggregation_columns
-            assert len(existing_agg_cols) < 2
-            if existing_agg_cols:
-                self.fields['group_by'].initial = self._get_property_id_by_indicator_id(existing_agg_cols[0])
-
-    @property
-    def container_fieldset(self):
-        return crispy.Div(
-            crispy.Fieldset(
-                _('Chart'),
-                hqcrispy.FieldWithHelpBubble(
-                    'group_by',
-                    help_bubble_text=_(
-                        "The values of the selected property will be aggregated "
-                        "and shown as bars in the chart."
-                    ),
-                    placeholder=_("Select Property..."),
-                ),
-                crispy.HTML(
-                    """<div class="controls col-sm-9 col-md-8 col-lg-6 col-sm-offset-3 col-md-offset-2 col-lg-offset-2"
-                             data-bind="visible:showGroupByValidationError">
-                             <strong class="text-danger">{error}</strong>
-                     </div>""".format(
-                        error=_("Please specify a property for the category.")
-                    )
-                )
-            ),
-            self.user_filter_fieldset,
-            self.default_filter_fieldset,
-            self.validation_error_text,
-        )
-
-    @property
-    def aggregation_field(self):
-        return self.cleaned_data["group_by"]
-
-    @property
-    def _report_aggregation_cols(self):
-        return [
-            self.data_source_properties[self.aggregation_field].column_id
-        ]
-
-    @property
-    def _report_charts(self):
-        agg_col = self.data_source_properties[self.aggregation_field].column_id
-        return [{
-            "type": "multibar",
-            "x_axis_column": agg_col,
-            "y_axis_columns": ["count"],
-        }]
-
-    @property
-    def _report_columns(self):
-        agg_col_id = self.data_source_properties[self.aggregation_field].column_id
-        agg_disp = self.data_source_properties[self.aggregation_field].text
-        return [
-            {
-                "format": "default",
-                "aggregation": "simple",
-                "field": agg_col_id,
-                "type": "field",
-                "display": agg_disp
-            },
-            {
-                "format": "default",
-                "aggregation": "sum",
-                "field": "count",
-                "type": "field",
-                "display": "Count"
-            }
-        ]
-
-    @property
-    def _group_by_choices(self):
-        return [(p.id, p.text) for p in self.data_source_properties.values()]
-
-    @property
-    @memoized
-    def _is_multiselect_chart_report(self):
-        """
-        Return True if this is a chart report aggregated by a multiselect question.
-        The data sources for these sorts of reports are handled differently than other reports.
-        """
-        agg_property = self.data_source_properties[self.aggregation_field]
-        return agg_property.type == "question" and agg_property.source['type'] == "MSelect"
-
-
-class ConfigurePieChartReportForm(ConfigureBarChartReportForm):
-    group_by = forms.ChoiceField(label=_("Pie Chart Segments"), required=False)
-
-    @property
-    def container_fieldset(self):
-        return crispy.Div(
-            crispy.Fieldset(
-                _('Chart Properties'),
-                hqcrispy.FieldWithHelpBubble(
-                    'group_by',
-                    help_bubble_text=_(
-                        "The values of the selected property will be aggregated "
-                        "and shows as the sections of the pie chart."
-                    ),
-                    placeholder=_(
-                        "Select Property..."
-                    ),
-                ),
-                crispy.HTML(
-                    """<div class="controls col-sm-9 col-md-8 col-lg-6 col-sm-offset-3 col-md-offset-2 col-lg-offset-2"
-                             data-bind="visible:showGroupByValidationError">
-                             <strong class="text-danger">{error}</strong>
-                     </div>""".format(
-                        error=_("Please select a property for the segment.")
-                    )
-                )
-
-            ),
-            self.user_filter_fieldset,
-            self.default_filter_fieldset,
-            self.validation_error_text,
-        )
-
-    @property
-    def _report_charts(self):
-        agg = self.data_source_properties[self.aggregation_field].column_id
-        return [{
-            "type": "pie",
-            "aggregation_column": agg,
-            "value_column": "count",
-        }]
-
-
 class ConfigureListReportForm(ConfigureNewReportBase):
     report_type = 'list'
     columns = JsonField(
         expected_type=list,
         null_values=([],),
-        required=True,
+        required=False,
         widget=forms.HiddenInput,
-        error_messages={"required": ugettext_lazy("At least one column is required")},
     )
     column_legend_fine_print = ugettext_noop(
-        u"Add columns to your report to display information from cases or form submissions. You may rearrange "
-        u"the order of the columns by dragging the arrows next to the column."
+        u"Add columns to your report to display information from cases or form submissions. You may rearrange the "
+        u"order of the columns by dragging the arrows next to the column."
     )
 
     @property
@@ -1288,9 +1235,10 @@
     def initial_columns(self):
         if self.existing_report:
             reverse_agg_map = {
+                'simple': 'Group By',
                 'avg': 'Average',
                 'sum': 'Sum',
-                'expand': 'Count per Choice'
+                'expand': COUNT_PER_CHOICE,
             }
             added_multiselect_columns = set()
             cols = []
@@ -1300,7 +1248,13 @@
                 )
                 indicator_id = mselect_indicator_id or c['field']
                 display = c['display']
+                agg = c.get("aggregation")
                 exists = self._column_exists(indicator_id)
+                if not exists:
+                    possibly_corrected_column_id = self._convert_v1_column_id_to_current_format(indicator_id)
+                    if self._column_exists(possibly_corrected_column_id):
+                        exists = True
+                        indicator_id = possibly_corrected_column_id
 
                 if mselect_indicator_id:
                     if mselect_indicator_id not in added_multiselect_columns:
@@ -1308,6 +1262,7 @@
                         display = MultiselectQuestionColumnOption.LABEL_DIVIDER.join(
                             display.split(MultiselectQuestionColumnOption.LABEL_DIVIDER)[:-1]
                         )
+                        agg = COUNT_PER_CHOICE
                     else:
                         continue
 
@@ -1315,26 +1270,97 @@
                     ColumnViewModel(
                         display_text=display,
                         exists_in_current_version=exists,
-                        property=self._get_column_option_by_indicator_id(indicator_id).id if exists else None,
+                        property=(
+                            self._get_column_option_by_indicator_id(indicator_id).get_property()
+                            if exists else None
+                        ),
                         data_source_field=indicator_id if not exists else None,
-                        calculation=reverse_agg_map.get(c.get('aggregation'), 'Count per Choice')
+                        calculation=reverse_agg_map.get(agg, COUNT_PER_CHOICE)
                     )
                 )
             return cols
-        return [ColumnViewModel(
-            display_text='',
+        else:
+            return self._get_default_columns()
+
+    def _get_default_columns(self):
+        if self.source_type == "case":
+            return self._get_default_case_report_columns()
+        else:
+            return self._get_default_form_report_columns()
+
+    def _get_default_case_report_columns(self):
+        cols = []
+        cols.append(ColumnViewModel(
+            display_text="Name",
             exists_in_current_version=True,
-            property=None,
-            data_source_field=None,
-            calculation=_('Count per Choice')
-        )]
+            property="name",
+            data_source_field=(
+                self.data_source_properties['name']
+                    .to_report_column_option()
+                    .get_indicator(COUNT_PER_CHOICE)['column_id']),
+            calculation=COUNT_PER_CHOICE
+        ))
+        cols.append(ColumnViewModel(
+            display_text="Owner",
+            exists_in_current_version=True,
+            property=COMPUTED_OWNER_NAME_PROPERTY_ID,
+            data_source_field=(
+                self.data_source_properties[COMPUTED_OWNER_NAME_PROPERTY_ID]
+                    .to_report_column_option()
+                    .get_indicator(COUNT_PER_CHOICE)['column_id']),
+            calculation=COUNT_PER_CHOICE
+        ))
+        case_props_found = 0
+
+        skip_list = set([COMPUTED_OWNER_NAME_PROPERTY_ID, COMPUTED_USER_NAME_PROPERTY_ID] + STATIC_CASE_PROPS)
+        for prop in self.data_source_properties.values():
+            if prop.get_type() == PROPERTY_TYPE_CASE_PROP and prop.get_id() not in skip_list:
+                case_props_found += 1
+                cols.append(ColumnViewModel(
+                    display_text=prop.get_text(),
+                    exists_in_current_version=True,
+                    property=prop.get_id(),
+                    data_source_field=prop.to_report_column_option().get_indicator(COUNT_PER_CHOICE)['column_id'],
+                    calculation=COUNT_PER_CHOICE,
+                ))
+                if case_props_found == 3:
+                    break
+        return cols
+
+    def _get_default_form_report_columns(self):
+        cols = []
+        prop = self.data_source_properties['username']
+        cols.append(ColumnViewModel(
+            display_text=prop.get_text(),
+            exists_in_current_version=True,
+            property=prop.get_id(),
+            data_source_field=prop.to_report_column_option().get_indicator(COUNT_PER_CHOICE)['column_id'],
+            calculation=COUNT_PER_CHOICE
+        ))
+        for prop in self.data_source_properties.values():
+            questions_found = 0
+            if prop.get_type() == PROPERTY_TYPE_QUESTION:
+                questions_found += 1
+                cols.append(ColumnViewModel(
+                    display_text=prop.get_text(),
+                    exists_in_current_version=True,
+                    property=prop.get_id(),
+                    data_source_field=prop.get_id(),
+                    calculation=COUNT_PER_CHOICE,
+                ))
+                if questions_found == 4:
+                    break
+        return cols
+
 
     @property
     def _report_columns(self):
         columns = []
         for i, conf in enumerate(self.cleaned_data['columns']):
             columns.extend(
-                self.report_column_options[conf['property']].to_column_dicts(i, conf['display_text'], "simple")
+                self.ds_builder.report_column_options[conf['property']].to_column_dicts(
+                    i, conf['display_text'], "simple"
+                )
             )
         return columns
 
@@ -1343,14 +1369,25 @@
         return ['doc_id']
 
 
-class ConfigureTableReportForm(ConfigureListReportForm, ConfigureBarChartReportForm):
+class ConfigureTableReportForm(ConfigureListReportForm):
     report_type = 'table'
     column_legend_fine_print = ugettext_noop(
-        u'Add columns for this report to aggregate. Each property you add will create a column for every value of '
-        u'that property.  For example, if you add a column for a yes or no question, the report will show a '
+        u'Add columns for this report to aggregate. Each property you add will create a column for every value '
+        u'of that property.  For example, if you add a column for a yes or no question, the report will show a '
         u'column for "yes" and a column for "no."'
     )
-    group_by = forms.ChoiceField(label=_("Show one row for each"), required=False)
+    group_by = forms.MultipleChoiceField(label=_("Show one row for each"))
+    chart = forms.CharField(widget=forms.HiddenInput)
+
+    def __init__(self, report_name, app_id, source_type, report_source_id, existing_report=None, *args, **kwargs):
+        super(ConfigureTableReportForm, self).__init__(
+            report_name, app_id, source_type, report_source_id, existing_report, *args, **kwargs
+        )
+        if self.source_type == "form":
+            self.fields['group_by'].widget = QuestionSelect(attrs={'class': 'input-large'})
+        else:
+            self.fields['group_by'].widget = Select2(attrs={'class': 'input-large'})
+        self.fields['group_by'].choices = self._group_by_choices
 
     @property
     def container_fieldset(self):
@@ -1361,8 +1398,8 @@
                     _("Rows"),
                     _(
                         'Choose which property this report will group its results by. Each value of this property'
-                        ' will be a row in the table. For example, if you choose a yes or no question, the report'
-                        ' will show a row for "yes" and a row for "no."'
+                        ' will be a row in the table. For example, if you choose a yes or no question, the report '
+                        'will show a row for "yes" and a row for "no."'
                     ),
                 ),
                 crispy.Field(
@@ -1384,76 +1421,90 @@
 
     @property
     def _report_charts(self):
-        # Override the behavior inherited from ConfigureBarChartReportForm
+
+        def get_non_agged_columns():
+            return [c for c in self._report_columns if c['aggregation'] != "simple"]
+        if get_non_agged_columns():
+            if self.cleaned_data['chart'] == "bar":
+                return [{
+                    "type": "multibar",
+                    "x_axis_column": "column_agg_0",
+                    # TODO: Possibly use more columns?
+                    "y_axis_columns": [
+                        {"column_id": c["column_id"], "display": c["display"]} for c in get_non_agged_columns()
+                    ],
+                }]
+            elif self.cleaned_data['chart'] == "pie":
+                return [{
+                    "type": "pie",
+                    "aggregation_column": "column_agg_0",
+                    "value_column": get_non_agged_columns()[0]['column_id'],
+                }]
         return []
 
     @property
     def _is_multiselect_chart_report(self):
+        """
+        Return True if this is a chart report aggregated by a multiselect question.
+        The data sources for these sorts of reports are handled differently than other reports.
+        """
+        # Disabling this feature for now
         return False
-
-    @property
-    @memoized
-    def report_column_options(self):
-        options = super(ConfigureTableReportForm, self).report_column_options
-        count_col = CountColumn("Number of Cases" if self.source_type == "case" else "Number of Forms")
-        options[count_col.id] = count_col
-        return options
+        # if self.cleaned_data['chart'] in ("pie", "bar"):
+        #     agg_property = self.data_source_properties[self.cleaned_data['group_by'][0]]
+        #     return agg_property.type == "question" and agg_property.source['type'] == "MSelect"
+        # return False
 
     @property
     def _report_columns(self):
-        agg_field_id = self.data_source_properties[self.aggregation_field].column_id
-        agg_field_text = self.data_source_properties[self.aggregation_field].text
+        agg_fields = self.cleaned_data['group_by']
+        agg_field_ids = set(
+            self.data_source_properties[agg_field].to_report_column_option().get_indicator("Group By")['column_id']
+            for agg_field in agg_fields
+        )
 
         columns = []
         for i, conf in enumerate(self.cleaned_data['columns']):
+            column = self.ds_builder.report_column_options[conf['property']]
             columns.extend(
-                self.report_column_options[conf['property']].to_column_dicts(
+                column.to_column_dicts(
                     i,
                     conf['display_text'],
                     conf['calculation'],
-                    is_aggregated_on=conf["property"] == self.aggregation_field
+                    conf['property'] in agg_fields
                 )
             )
 
         # Add the aggregation indicator to the columns if it's not already present.
-        displaying_agg_column = any(
-            c for c in self.cleaned_data['columns'] if c['property'] == self.aggregation_field
-        )
-        if not displaying_agg_column:
-            columns = self._get_column_option_by_indicator_id(agg_field_id).to_column_dicts(
-                "agg", agg_field_text, 'simple', is_aggregated_on=True
-            ) + columns
-        else:
-            # Don't expand the aggregation column
-            for c in columns:
-                if c['field'] == agg_field_id:
-                    c['aggregation'] = "simple"
-        return columns
-
-    @property
-    @memoized
-    def initial_columns(self):
-        # columns are ColumnViewModels (not ColumnOptions)
-        columns = super(ConfigureTableReportForm, self).initial_columns
-
-        # Remove the aggregation indicator from the columns.
-        # It gets removed because we want it to be a column in the report,
-        # but we don't want it to appear in the builder.
-        if self.existing_report:
-            agg_properties = [
-                self._get_property_id_by_indicator_id(c)
-                for c in self.existing_report.aggregation_columns
-            ]
-            return [c for c in columns if c.property not in agg_properties]
+        extra_cols = []
+        existing_columns = set(c['property'] for c in self.cleaned_data['columns'])
+        for index, agg_field in enumerate(agg_fields):
+            if agg_field not in existing_columns:
+                column = self.ds_builder.report_column_options[agg_field]
+                agg_field_text = column.get_default_display()
+                extra_cols += column.to_column_dicts(
+                    "agg_{}".format(index), agg_field_text, "simple", is_aggregated_on=True
+                )
+        columns = extra_cols + columns
+
+        # Don't expand the aggregation columns
+        for c in columns:
+            if c['field'] in agg_field_ids:
+                c['aggregation'] = "simple"
+
         return columns
 
     @property
     @memoized
     def _report_aggregation_cols(self):
-        # we want the bar chart behavior, which is reproduced here:
         return [
-            self.data_source_properties[self.aggregation_field].column_id
+            self.data_source_properties[f].to_report_column_option().get_indicator("Group By")['column_id']
+            for f in self.cleaned_data['group_by']
         ]
+
+    @property
+    def _group_by_choices(self):
+        return [(p.get_id(), p.get_text()) for p in self.data_source_properties.values()]
 
 
 class ConfigureWorkerReportForm(ConfigureTableReportForm):
@@ -1461,8 +1512,8 @@
     report_type = 'worker'
     column_legend_fine_print = ugettext_noop(
         u'Add columns for this report to aggregate. Each property you add will create a column for every value of '
-        u'that property. For example, if you add a column for a yes or no question, the report will show a '
-        u'column for "yes" and a column for "no".'
+        u'that property. For example, if you add a column for a yes or no question, the report will show a column '
+        u'for "yes" and a column for "no".'
     )
 
     def __init__(self, *args, **kwargs):
@@ -1474,7 +1525,7 @@
         if self.source_type == "form":
             return "username"
         if self.source_type == "case":
-            return "computed/user_name"
+            return COMPUTED_USER_NAME_PROPERTY_ID
 
     @property
     @memoized
@@ -1489,7 +1540,7 @@
             ),
             UserFilterViewModel(
                 exists_in_current_version=True,
-                property='computed/user_name',
+                property=COMPUTED_USER_NAME_PROPERTY_ID,
                 data_source_field=None,
                 display_text='user name',
                 format='Choice',
@@ -1539,7 +1590,7 @@
 
     @property
     def _location_choices(self):
-        return [(p.id, p.text) for p in self.data_source_properties.values()]
+        return [(p.get_id(), p.get_text()) for p in self.data_source_properties.values()]
 
     @property
     def container_fieldset(self):
@@ -1585,19 +1636,28 @@
 
     @property
     def _report_columns(self):
-        loc_field_id = self.data_source_properties[self.location_field].column_id
-        loc_field_text = self.data_source_properties[self.location_field].text
-
         columns = super(ConfigureMapReportForm, self)._report_columns
 
-        # Add the location indicator to the columns if it's not already present.
-        displaying_loc_column = bool([c for c in columns if c['field'] == loc_field_id])
-        if not displaying_loc_column:
-            columns = columns + [{
-                "column_id": loc_field_id,
-                "type": "location",
-                'field': loc_field_id,
-                'display': loc_field_text
-            }]
+        if self.location_field:
+            loc_column = self.data_source_properties[self.location_field].to_report_column_option()
+            loc_indicator = loc_column.get_indicator("simple")
+            loc_field_id = loc_indicator['column_id']
+            loc_field_text = loc_column.get_default_display()
+
+            displaying_loc_column = False
+            for c in columns:
+                if c['field'] == loc_field_id:
+                    c['type'] = "location"
+                    displaying_loc_column = True
+                    break
+
+            # Add the location indicator to the columns if it's not already present.
+            if not displaying_loc_column:
+                columns = columns + [{
+                    "column_id": loc_field_id,
+                    "type": "location",
+                    'field': loc_field_id,
+                    'display': loc_field_text
+                }]
 
         return columns
